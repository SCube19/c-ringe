//Code example #1
int x;                      //no initialization
int a = 0;                  //integer initialization
string y;                   // string initialization
char z = 'z';               // character initialization
bool b = true;              // bool initialization
fun [ -> ] f = () -> {};    //function initialization with lambda expression

inc a;                      //increment
dec a;                      //decrement
x = a;                      //assignment
x = x + 2;                  //arithmetic

print(x <= y);              //comparisons and build-in print
print(x >= y);              /*multiline
                                comment*/
print(x is y);
print(x > y);
print(x < y);
print(x is not y);

//Demonstrates:
//(1) 3+ types
//(2) literals, arithmetic and comparisons
//(3) variables and assignment
//(4) build-in print
//(12) static typing
//(*) decrement and increment
//(*) comments


//Code example #2
immutable int size = 10;                //mimicing user input in read-only variable

if(size >= 10)                          //if doesn't have to be inside a block C-style
    print("WOW! Such a huge triangle!");

if(size <= 0)                           //as to not make any conflicts if-else has to be inside a block not matter what
{                         
    int i = 0;
    while(i <= size)                    //C-style while loop
    {
        from x = 0 to i do              //range for loop with const value x (mandatory even if not used)
            print('*');
        print('\n');
        inc i;
    }
} else {
    print("size too small");
}

//Demonstrates:
//(5) while, if
//(8) read-only variables and for loop


//Code example #3
fun [int -> int] fac = (int n) -> int {        //function definiton that takes integer and returns an integer
    if (n is 0)
        return 1;                   
    return n * fac(n - 1);
}; 

fun [int -> ] printFac = (int n) -> { //procedure definiton
    print(fac(n));                 //function application
};

printFac(5);                       //procedure application

//Demonstrates:
//(6) functions and procedures
//(11) functions returning values


//Code example #4
fun [ref int -> ] add5ref = (ref int x) -> {   //pass by reference
    x = x + 5;
};

fun [int -> int] add5 = (int x) -> int {           //pass by value
    x = x + 5;
    return x;
};

int x = 0;
add5ref(x);                             // x = 5
int y = add5(x);                        // y = 10, x = 5

//Demonstrates:
//(7) pass by reference and pass by value


//Code example #5
fun [int -> ] outer = (int x) -> {
    fun [string -> string] error = (string y) -> string {        //inner function
        return "Error: " + y;
    };
    if (x < 0) {
        print(error);
    } else { 
        print("x is non-negative");
    }
};

outer(-1);

//Demonstrates:
//(13) inner functions


//Code example #6
//higher order functions and lambdas
fun [int, int, fun [int, int -> int] -> ] apply = (int x, int y, fun [int, int -> int] f) ->  {   //higher order function
    return f(x, y);
}; 

int x = 4;
int y = 10;

print(apply(4, 10, (int x, int y) -> int {return x*x + y*y + 2*x*y;}));   //lambda expression

//closures
fun [int -> fun [-> int]] counter = (int startValue) -> fun [-> int] {
    return () -> int {startValue = startValue + 1; return startValue;};   //counter closure
};

fun [-> int] count = counter(0);
count();
count();
print(count());

//Demonstrates:
//(17) higher order functions, lambdas and closures


//Code example #7
int i = 0;
while(true) {
    inc i;
    if (i < 10)
        skip;       //continue
    exit;           //break
}

//Demonstrates:
//(16) break, continue

//(9) and (10) are supported by grammar but can't really be shown at this point as they are syntactic features
